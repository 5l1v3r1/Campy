using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Swigged.LLVM;

namespace Campy.ControlFlowGraph
{

    // Allocation type information for a stack allocation.
    //
    // While some of the following information is deducible
    // from the Alloca instruction (ex: GcPointer/Aggregate)
    // we cache the information in the flag bits instead of
    // walking through the type every time.
    public enum AllocaFlags
    {
        None = 0x0,
        GcPointer = 0x1,
        GcAggregate = 0x2,
        GcValue = GcPointer | GcAggregate,
        Pinned = 0x4,
        GsCookie = 0x8,
        SecurityObject = 0x10,
        GenericsContext = 0x20
    };

    // Per stack allocation GcInfo
    //
    // This Data-structure records the frame-offsets for certain special
    // allocations in each function generated by LLILC. This includes:
    //  -> Special Symbols: GsCookie, SecurityObject, GenericsContext
    //                      which must be identified to the runtime.
    //  -> Pinned pointers: Whose location must be reported to the runtime.
    //  -> GC Aggregates:   Location of all aggregates containing GC pointers
    //                      allocated on the stack
    //  -> GC Pointers:     GC Pointers allocated on the stack.
    //
    // Gc Pointers and GC aggregates are collectively referred to as GC Values.
    //
    // The stackmap generated via Statepoints only handles SSA values,
    // and therefore does not track pointers within stack allocated GC Values.
    //
    // To circumvent this problem, we report all pointers within stack allocated
    // GC Values as untracked.
    // These stack allocations are known to be live throughout the function,
    // because the reader marks them as frame-escaped.
    public class AllocaInfo
    {
        public Int32 Offset;
        public AllocaFlags Flags; // Combination of AllocaFlags, to be precise.

        public AllocaInfo(Int32 o, AllocaFlags f)
        {
            Offset = o;
            Flags = f;
        }

        public string getAllocTypeString()
        {
            if ((Flags & AllocaFlags.GsCookie) != 0)
            {
                return "GS Cookie";
            }

            if (0 != (Flags & AllocaFlags.GenericsContext))
            {
                if (0 != (Flags & AllocaFlags.GcPointer))
                {
                    return "GenericsContextThis";
                }
                else
                {
                    return "GenericsContextTypeArg";
                }
            }

            if (0 != (Flags & AllocaFlags.SecurityObject))
            {
                return "SecurityObject";
            }

            if (0 != (Flags & AllocaFlags.GcPointer))
            {
                return "GcPointer";
            }

            if (0 != (Flags & AllocaFlags.GcAggregate))
            {
                return "GcAggregate";
            }
            return "fuck";
        }

        public bool isGcPointer() { return ((Flags & AllocaFlags.GcPointer) != 0); }
        public bool isGcAggregate() {
            return ((Flags & AllocaFlags.GcAggregate) != 0);
        }
        public bool isGcValue() { return ((Flags & (AllocaFlags.GcValue)) != 0); }
        public bool isPinned() { return ((Flags & AllocaFlags.Pinned) != 0); }
    };

    /// \brief Per Function GcInfo
    /// Allocation map for stack allocated GC Values
    /// and special symbols.
    public class GcFuncInfo
    {
        public GcFuncInfo(Function F)
        {
        }

        public void recordGcAlloca(Value Alloca)
        {
            recordAlloca(Alloca);
            Debug.Assert(AllocaMap[Alloca].isGcValue(), "Expected GcValue");
        }

        // Mark additional annotations on a recorded GC Value
        public void markGcAlloca(Value aa, AllocaFlags Flags)
        {
            Debug.Assert(GcInfo.isGcAllocation(aa), "GcValue expected");
            Debug.Assert(hasRecord(aa), "Missing Alloca recorded");

            AllocaInfo a = AllocaMap[aa];
            Debug.Assert(a.isGcValue(), "GcValue is recorded incorrectly");
            Debug.Assert(a.Offset == GcInfo.InvalidPointerOffset, "Changing annotation after GcInfoRecorder");

            a.Flags = (AllocaFlags)(a.Flags | Flags);
        }

        // Mark additional annotations on a recorded non-GC-Value
        public void markNonGcAlloca(Value Alloca, AllocaFlags Flags)
        {
            Debug.Assert(GcInfo.isGcAllocation(Alloca), "GcValue expected");
            Debug.Assert(hasRecord(Alloca), "Missing Alloca recorded");

            AllocaInfo AllocaInfo = AllocaMap[Alloca];
            Debug.Assert(AllocaInfo.isGcValue(), "GcValue is recorded incorrectly");
            Debug.Assert(AllocaInfo.Offset == GcInfo.InvalidPointerOffset, "Changing annotation after GcInfoRecorder");

            AllocaInfo.Flags = (AllocaFlags)(AllocaInfo.Flags | Flags);
        }


        public void recordPinned(Value Alloca)
        {
            markGcAlloca(Alloca, AllocaFlags.Pinned);
        }

        public void recordSecurityObject(Value Alloca)
        {
            markGcAlloca(Alloca, AllocaFlags.SecurityObject);
        }

        public void recordGsCookie(Value Alloca, UInt32 ValidRangeStart,
            UInt32 ValidRangeEnd)
        {
            // TODO: This feature is untested.
            // Reader doesn't implement GS Cookie guard yet.
            // Implement stack protection checks
            // https://github.com/dotnet/llilc/issues/353
            Debug.Assert(false, "UnTested");

            //recordAlloca(Alloca);
            //markNonGcAlloca(Alloca, AllocaFlags::SecurityObject);
            //GsCkValidRangeStart = ValidRangeStart;
            //GsCkValidRangeEnd = ValidRangeEnd;
        }

        //public void recordGenericsContext(Value Alloca, GENERIC_CONTEXTPARAM_TYPE ParamType);

        public bool hasRecord(Value Alloca)
        {
            return AllocaMap.ContainsKey(Alloca);
        }

        public void getEscapingLocations(List<Value> EscapingLocs)
        {
            foreach (KeyValuePair<Value, AllocaInfo> i in AllocaMap)
            {
                EscapingLocs.Add(i.Key);
            }
        }

        // Function for which GcInfo is recorded
        public Function Function;

        // Alloca Instruction to AllocaInfo Map, for:
        // a) All stack allocated GC Values
        // b) Certain special allocations like Generics Context Parameter,
        //    which are not of GC-type.
        public Dictionary<Value, AllocaInfo> AllocaMap = new Dictionary<Value, AllocaInfo>();

        // Additional information for special slots
        public UInt32 GsCkValidRangeStart;
        public UInt32 GsCkValidRangeEnd;
        //public GENERIC_CONTEXTPARAM_TYPE GenericsContextParamType;
        public UInt32 PSPSymOffset;
        public bool HasFunclets;

        // Record a Stack Allocation in the FuncInfo, with appropriate
        // Flags based on Type of allocation.
        public void recordAlloca(Value Alloca)
        {
            //ValueRef vr = Alloca.V;
            //TypeRef alt = LLVM.GetAllocatedType(vr);
            //Debug.Assert(!hasRecord(Alloca), "Duplicate Allocation");
            //Type Type = new Type(alt);
            //AllocaFlags Flags = AllocaFlags.None;

            //if (GcInfo.isGcPointer(Type))
            //{
            //    Flags = AllocaFlags.GcPointer;
            //}
            //else if (GcInfo.isGcAggregate(Type))
            //{
            //    Flags = AllocaFlags.GcAggregate;
            //}

            //AllocaMap[Alloca] = new AllocaInfo(GcInfo.InvalidPointerOffset, Flags);
        }

    };

    public class GcInfo
    {
        public static UInt32 UnmanagedAddressSpace = 0;
        public static UInt32 ManagedAddressSpace = 1;
        public static Int32 InvalidPointerOffset = -1;

        public static bool isGcPointer(Type type)
        {
            if (type.isPointerTy())
            {
                TypeRef tr = type.IntermediateType;
                return LLVM.GetPointerAddressSpace(tr) == ManagedAddressSpace;
            }
            return false;
        }

        public static bool isGcAggregate(Type type)
        {
            //if (type.isVectorTy())
            //{
            //    Type st = type.getScalarType();
            //    return isGcPointer(st);
            //}
            //if (type.isArrayTy())
            //{
            //    TypeRef et = LLVM.GetElementType(type.IntermediateType);
            //    return isGcPointer(new Type(et));
            //}
            //if (type.isStructTy())
            //{
            //    uint count = LLVM.CountStructElementTypes(type.IntermediateType);
            //    TypeRef[] dest = new TypeRef[count];
            //    LLVM.GetStructElementTypes(type.IntermediateType, dest);
            //    foreach (TypeRef subtype in dest)
            //    {
            //        if (isGcType(new Type(subtype)))
            //        {
            //            return true;
            //        }
            //    }
            //}
            return false;
        }

        public static bool isGcType(Type Type)
        {
            return isGcPointer(Type) || isGcAggregate(Type);
        }

        public static bool isUnmanagedPointer(Type Type)
        {
            return Type.isPointerTy() && !isGcPointer(Type);
        }

        public static bool isGcValue(Value Value)
        {
            return isGcType(Value.T);
        }

        public static bool isGcAllocation(Value value)
        {
            //var x = LLVM.GetAllocatedType(value.V);
            //return isGcType(new Type(x));
            return false;
        }

        public static bool isGcFunction(Function f)
        {
            string n = LLVM.GetGC(f.V);
            return "coreclr" == n;
        }

        public static bool isFPBasedFunction(Function F)
        {
            // TODO -- unimplemented.
            return false;
        }

        //public static void getGcPointers(StructType StructTy,
        //    DataLayout DataLayout,
        //    Vector<Uint32, 4> GcPtrOffsets);

        public GcFuncInfo newGcInfo(Function f)
        {
            Debug.Assert(getGcInfo(f) == null, "Duplicate GcInfo");
            GcFuncInfo GcFInfo = new GcFuncInfo(f);
            GcInfoMap[f] = GcFInfo;
            return GcFInfo;
        }

        public GcFuncInfo getGcInfo(Function f)
        {
            if (!GcInfoMap.ContainsKey(f))
            {
                return null;
            }
            GcFuncInfo GcFInfo = GcInfoMap[f];
            Debug.Assert(f == GcFInfo.Function, "Function mismatch");

            return GcFInfo;
        }

        public Dictionary<Function, GcFuncInfo> GcInfoMap = new Dictionary<Function, GcFuncInfo>();
    }
}
